open Ros_messages;; 
open Imandra_prelude;;

type incoming_msg = 
  | Clock  of Rosgraph_msgs.clock
  | Sensor of Sensor_msgs.laser_scan

type outgoing_msg =
  | Twist of Geometry_msgs.twist

type state =
  { min_range : Basic_types.float option
  ; incoming  : incoming_msg option
  ; outgoing  : outgoing_msg option 
  }

let init_state = 
  { min_range = None
  ; incoming  = None
  ; outgoing  = None 
  }

let get_min_range msg : Basic_types.float = 
  let max = msg.Sensor_msgs.range_max in
  let lt a b = Basic_types.( a.value < b.value ) in
  let min = List.fold_left (fun a b -> if lt a b then a else b) max in
  min msg.Sensor_msgs.ranges
  
let make_twist_message v omega =
  let open Geometry_msgs in
  let precision = 10000 in
  let mkvector x y z = 
    let x = Basic_types.{value = x; precision} in
    let y = Basic_types.{value = y; precision} in
    let z = Basic_types.{value = z; precision} in
    { x; y; z } 
    in 
  Twist { linear  = mkvector v 0 0
        ; angular = mkvector 0 0 omega 
        } 

let one_step state =
  match state.incoming with None -> state | Some in_msg ->
  let state = { state with incoming = None; outgoing = None } in
  match in_msg with 
  | Sensor laserScan -> 
    { state with min_range = Some (get_min_range laserScan) }
  | Clock  _ -> begin
    match state.min_range with None -> state | Some min_range ->
    if min_range.value < 500 
    then { state with outgoing = Some (make_twist_message 0 100) } 
    else { state with outgoing = Some (make_twist_message 100 0) }
  end